/* Generated by Nim Compiler v0.10.2 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Linux, amd64, clang */
/* Command for C compiler:
   clang -c -w -O3  -I/usr/lib/nim -o /home/kozak/Devel/D/Trash/source/nimcache/brainfuck.o /home/kozak/Devel/D/Trash/source/nimcache/brainfuck.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>

#include <stdio.h>
typedef struct program136171 program136171;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct table136178 table136178;
typedef struct keyvaluepairseq136181 keyvaluepairseq136181;
typedef struct keyvaluepair136184 keyvaluepair136184;
typedef struct tape136008 tape136008;
typedef struct TY136010 TY136010;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct keyvaluepair136184 {
NU8 Field0;
NI Field1;
NI Field2;
};
struct  table136178  {
keyvaluepairseq136181* Data;
NI Counter;
};
struct  program136171  {
NimStringDesc* Code;
table136178 Bracketmap;
};
struct  tape136008  {
NI Pos;
TY136010* Tape;
};
typedef N_NIMCALL_PTR(void, TY3089) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY3094) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY3089 marker;
TY3094 deepcopy;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct keyvaluepairseq136181 {
  TGenericSeq Sup;
  keyvaluepair136184 data[SEQ_DECL_SIZE];
};
struct TY136010 {
  TGenericSeq Sup;
  NI data[SEQ_DECL_SIZE];
};
N_NIMCALL(void, run_136840)(program136171* prog);
N_NIMCALL(void, newtape_136015)(tape136008* Result);
N_NIMCALL(void, TMP25)(void* p, NI op);
N_NIMCALL(void, genericSeqAssign)(void* dest, void* src_79604, TNimType* mt);
N_NOINLINE(void, chckNil)(void* p);
N_NIMCALL(void, inc_136042)(tape136008* self);
N_NIMCALL(void, dec_136064)(tape136008* self);
N_NIMCALL(void, advance_136086)(tape136008* self);
N_NIMCALL(TGenericSeq*, incrSeq)(TGenericSeq* seq, NI elemsize);
N_NIMCALL(void, devance_136137)(tape136008* self);
N_NIMCALL(NI, get_136160)(tape136008 self);
N_NIMCALL(NI, HEX5BHEX5D_136852)(table136178 t_136859, NI key_136862);
N_NIMCALL(void, write_12873)(FILE* f, NIM_CHAR c);
N_NIMCALL(void, newprogram_136200)(NimStringDesc* code, program136171* Result);
N_NIMCALL(void, inittable_136205)(NI initialsize_136210, table136178* Result);
N_NIMCALL(void, unsureAsgnRef)(void** dest, void* src);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(TY136010*, newseq_136438)(NI len_136442);
N_NIMCALL(NIM_BOOL, contains_95245)(NimStringDesc* s, NIM_CHAR c);
static N_INLINE(NI, pop_136507)(TY136010** s_136515);
N_NIMCALL(TGenericSeq*, setLengthSeq)(TGenericSeq* seq, NI elemsize, NI newlen);
N_NIMCALL(void, add_136555)(table136178* t_136564, NI key_136568, NI val_136570);
N_NIMCALL(NimStringDesc*, addChar)(NimStringDesc* s, NIM_CHAR c);
N_NIMCALL(NimStringDesc*, readfile_12842)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, paramstr_132609)(NI i);
static N_INLINE(void, initStackBottomWith)(void* locals);
N_NOINLINE(void, setStackBottom)(void* thestackbottom);
NIM_EXTERNC N_NOINLINE(void, systemInit)(void);
NIM_EXTERNC N_NOINLINE(void, systemDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_parseutilsInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_parseutilsDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_strutilsInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_strutilsDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_hashesInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_hashesDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_timesInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_timesDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_mathInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_mathDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_tablesInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_tablesDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_sequtilsInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_sequtilsDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_posixInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_posixDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_osInit)(void);
NIM_EXTERNC N_NOINLINE(void, HEX00_osDatInit)(void);
NIM_EXTERNC N_NOINLINE(void, brainfuckInit)(void);
NIM_EXTERNC N_NOINLINE(void, brainfuckDatInit)(void);
NIM_CONST struct {
  TGenericSeq Sup;
  NI data[1];
} CNSTSEQ25 = {{1, 1}, {0}};
NIM_CONST TY136010* TMP23 = ((TY136010*)&CNSTSEQ25);
STRING_LITERAL(TMP38, "", 0);
STRING_LITERAL(TMP39, "+-<>[].,", 8);
extern TNimType NTI108; /* int */
TNimType NTI136010; /* seq[int] */
N_NIMCALL(void, TMP25)(void* p, NI op) {
	TY136010* a;
	NI LOC1;
	a = (TY136010*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	}
}

N_NIMCALL(void, newtape_136015)(tape136008* Result) {
	(*Result).Pos = 0;
	genericSeqAssign((&(*Result).Tape), TMP23, (&NTI136010));
}

N_NIMCALL(void, inc_136042)(tape136008* self) {
	(*self).Tape->data[(*self).Pos] += 1;
}

N_NIMCALL(void, dec_136064)(tape136008* self) {
	(*self).Tape->data[(*self).Pos] -= 1;
}

N_NIMCALL(void, advance_136086)(tape136008* self) {
	(*self).Pos += 1;
	{
		if (!((*self).Tape->Sup.len <= (*self).Pos)) goto LA3;
		(*self).Tape = (TY136010*) incrSeq(&((*self).Tape)->Sup, sizeof(NI));
		(*self).Tape->data[(*self).Tape->Sup.len-1] = 0;
	}
	LA3: ;
}

N_NIMCALL(void, devance_136137)(tape136008* self) {
	{
		if (!(0 < (*self).Pos)) goto LA3;
		(*self).Pos -= 1;
	}
	LA3: ;
}

N_NIMCALL(NI, get_136160)(tape136008 self) {
	NI result;
	result = 0;
	result = self.Tape->data[self.Pos];
	return result;
}

N_NIMCALL(void, run_136840)(program136171* prog) {
	NI pc;
	tape136008 tape;
	pc = 0;
	memset((void*)(&tape), 0, sizeof(tape));
	chckNil((void*)(&tape));
	memset((void*)(&tape), 0, sizeof(tape));
	newtape_136015((&tape));
	{
		while (1) {
			if (!(pc < (*prog).Code->Sup.len)) goto LA2;
			switch (((NU8)((*prog).Code->data[pc]))) {
			case 43:
			{
				inc_136042((&tape));
			}
			break;
			case 45:
			{
				dec_136064((&tape));
			}
			break;
			case 62:
			{
				advance_136086((&tape));
			}
			break;
			case 60:
			{
				devance_136137((&tape));
			}
			break;
			case 91:
			{
				{
					NI LOC10;
					LOC10 = 0;
					LOC10 = get_136160(tape);
					if (!(LOC10 == 0)) goto LA11;
					pc = HEX5BHEX5D_136852((*prog).Bracketmap, pc);
				}
				LA11: ;
			}
			break;
			case 93:
			{
				{
					NI LOC16;
					LOC16 = 0;
					LOC16 = get_136160(tape);
					if (!!((LOC16 == 0))) goto LA17;
					pc = HEX5BHEX5D_136852((*prog).Bracketmap, pc);
				}
				LA17: ;
			}
			break;
			case 46:
			{
				NI LOC20;
				LOC20 = 0;
				LOC20 = get_136160(tape);
				write_12873(stdout, ((NIM_CHAR) (((NI) (LOC20)))));
				fflush(stdout);
			}
			break;
			default:
			{
			}
			break;
			}
			pc += 1;
		} LA2: ;
	}
}

static N_INLINE(NI, pop_136507)(TY136010** s_136515) {
	NI result;
	NI l;
	result = 0;
	l = (NI64)((*s_136515)->Sup.len - 1);
	result = (*s_136515)->data[l];
	(*s_136515) = (TY136010*) setLengthSeq(&((*s_136515))->Sup, sizeof(NI), l);
	return result;
}

N_NIMCALL(void, newprogram_136200)(NimStringDesc* code, program136171* Result) {
	NI pc;
	TY136010* leftstack;
	inittable_136205(64, (&(*Result).Bracketmap));
	unsureAsgnRef((void**) (&(*Result).Code), copyString(((NimStringDesc*) &TMP38)));
	pc = 0;
	leftstack = newseq_136438(0);
	{
		NIM_CHAR c_136473;
		NI i_136819;
		NI l_136821;
		c_136473 = 0;
		i_136819 = 0;
		l_136821 = code->Sup.len;
		{
			while (1) {
				if (!(i_136819 < l_136821)) goto LA3;
				c_136473 = code->data[i_136819];
				{
					{
						NIM_BOOL LOC7;
						LOC7 = 0;
						LOC7 = contains_95245(((NimStringDesc*) &TMP39), c_136473);
						if (!!(LOC7)) goto LA8;
						goto LA4;
					}
					LA8: ;
					{
						if (!((NU8)(c_136473) == (NU8)(91))) goto LA12;
						leftstack = (TY136010*) incrSeq(&(leftstack)->Sup, sizeof(NI));
						leftstack->data[leftstack->Sup.len-1] = pc;
					}
					LA12: ;
					{
						NIM_BOOL LOC16;
						NI left;
						LOC16 = 0;
						LOC16 = ((NU8)(c_136473) == (NU8)(93));
						if (!(LOC16)) goto LA17;
						LOC16 = (0 < leftstack->Sup.len);
						LA17: ;
						if (!LOC16) goto LA18;
						left = pop_136507((&leftstack));
						add_136555((&(*Result).Bracketmap), pc, left);
						add_136555((&(*Result).Bracketmap), left, pc);
					}
					LA18: ;
					(*Result).Code = addChar((*Result).Code, c_136473);
					pc += 1;
				} LA4: ;
				i_136819 += 1;
			} LA3: ;
		}
	}
}

static N_INLINE(void, initStackBottomWith)(void* locals) {
	setStackBottom(locals);
}
void PreMainInner() {
	systemInit();
	HEX00_parseutilsDatInit();
	HEX00_strutilsDatInit();
	HEX00_hashesDatInit();
	HEX00_timesDatInit();
	HEX00_mathDatInit();
	HEX00_tablesDatInit();
	HEX00_sequtilsDatInit();
	HEX00_posixDatInit();
	HEX00_osDatInit();
	brainfuckDatInit();
	HEX00_parseutilsInit();
	HEX00_strutilsInit();
	HEX00_hashesInit();
	HEX00_timesInit();
	HEX00_mathInit();
	HEX00_tablesInit();
	HEX00_sequtilsInit();
	HEX00_posixInit();
	HEX00_osInit();
}

void PreMain() {
	void (*volatile inner)();
	systemDatInit();
	inner = PreMainInner;
	initStackBottomWith((void *)&inner);
	(*inner)();
}

int cmdCount;
char** cmdLine;
char** gEnv;
N_CDECL(void, NimMainInner)(void) {
	brainfuckInit();
}

N_CDECL(void, NimMain)(void) {
	void (*volatile inner)();
	PreMain();
	inner = NimMainInner;
	initStackBottomWith((void *)&inner);
	(*inner)();
}

int main(int argc, char** args, char** env) {
	cmdLine = args;
	cmdCount = argc;
	gEnv = env;
	NimMain();
	return nim_program_result;
}

NIM_EXTERNC N_NOINLINE(void, brainfuckInit)(void) {
	NimStringDesc* LOC1;
	NimStringDesc* LOC2;
	program136171 LOC3;
	LOC1 = 0;
	LOC1 = paramstr_132609(1);
	LOC2 = 0;
	LOC2 = readfile_12842(LOC1);
	memset((void*)(&LOC3), 0, sizeof(LOC3));
	newprogram_136200(LOC2, (&LOC3));
	run_136840((&LOC3));
}

NIM_EXTERNC N_NOINLINE(void, brainfuckDatInit)(void) {
NTI136010.size = sizeof(TY136010*);
NTI136010.kind = 24;
NTI136010.base = (&NTI108);
NTI136010.flags = 2;
NTI136010.marker = TMP25;
}

